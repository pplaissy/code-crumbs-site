<!doctype html>
<html lang="en">
<head>
        <base href="../..">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Some code crumbs dropped along my coding <path/>">
        <meta name="keywords" content="Eleventy, Web Components, JS, HTML, JavaScript, SVG">
        <meta name="generator" content="Eleventy">
        <meta name="author" content="Pierre Plaissy">

        <meta property="og:title" content="How to code a drawing undo/redo feature">
        <meta property="og:type" content="article">
        <meta property="og:URL" content="https://code-crumbs.pplaissy.fr/posts/undo-redo/">
        <meta property="og:image" content="https://code-crumbs.pplaissy.fr/assets/img/undo-redo/thumbnail.png">
        <meta property="og:description" content="An undo/redo drawing feature from scratch, step by step and with a really cool and innovative bonus">

        <title>Code crumbs</title>
        <link rel="icon" href="assets/img/favicon.ico">
        <link rel="stylesheet" href="assets/css/main.css">
        <link rel="stylesheet" href="assets/css/posts.css">
    </head>
    <body>
        <nav class="header">
  <div class="avatar">
    <img src="assets/img/me.png" alt="me" class="profile-img mr">
    <!-- <span class="copy" @html="'&copy; ' + currentYear() + ' P. Plaissy'"></span> -->
  </div>
  <div class="title">
    <div class="main">
      <a href="#" class="nav-item mr">code crumbs...</a>
      <a href="https://www.linkedin.com/in/pierreplaissy/" aria-label="LinkedIn" target="_blank" rel="noopener noreferrer" class="linkedin">
    <img src="assets/img/linkedin.svg" alt="LinkedIn" width="24" height="24" class="mb-1">
</a>

    </div>
    <div class="epigraph">
      <span>Some code crumbs dropped along my coding &lt;path/&gt;</span>
    </div>
  </div>
</nav>
<link rel="stylesheet" href="assets/css/header.css">

        <div class="main-container">
            <h1>How to code a drawing undo/redo feature</h1>
<article><p>The principle is well known so there's no need to describe it. Let's just remember that we're in the special environment of an SVG editor, and that undo/redo operations to the modifications of graphical entities, lines, circles, paths, etc.</p>
<h2>Drawing action</h2>
<p>If you want to undo a modification to a graphical entity, you must of course have stored the entity's state before the modification. And if you want to restore an undone modification, you must first have stored the entity's modified state.</p>
<p>Let's set up a <strong>DrawingAction</strong> class designed to store the modification of an entity, i.e. both its "<strong>prevState</strong>" state before modification and its "<strong>nextState</strong>" state after modification. We also store "<strong>entity</strong>", a pointer to the entity itself, so we can change its state right here by applying "<strong>prevState</strong>" or "<strong>nextState</strong>" as appropriate.</p>
<pre><code class="language-typescript">export class DrawingAction {
    entity: any;
    prevState: any;
    nextState: any;
    status: UndoStateEnum = UndoStateEnum.pending;
}
</code></pre>
<p>To reverse a state, you need to know "<strong>status</strong>" of the current state. I use a "<strong>UndoStateEnum</strong>" enum that lets me know whether the modification is in progress, undone or restored:</p>
<pre><code class="language-typescript">export enum UndoStateEnum {
    pending = 0,
    restored,
    undone
}
</code></pre>
<h3>Starting an update</h3>
<p>A <strong>DrawingAction</strong> is created when a modification action begins. A [service](#undo service), which we'll see a little later, receives the storage request and generates as many <strong>DrawingActions</strong> as there are selected entities to be modified.</p>
<pre><code class="language-typescript">export class DrawingAction {
	...
    cudOp: UndoCUDOpEnum;
    
    constructor(e: any, cudOp: UndoCUDOpEnum) { 
        this.entity = e;
        this.cudOp = cudOp;
        this.prevState = this.cloneState(e);
    }
}
</code></pre>
<p>Le constructeur reçoit l'entité qui est de type any. J'aurais pu lui donner le type de base de mes entités mais j'ai préféré rester générique à ce stade, cette pouvant servir dans différents contextes. Le "<strong>cudOp</strong>" indique le type d'opération CUD (Create, Update, Delete) commencé sur les entités sélectionnées. On a besoin de cette information car ce n'est pas la même chose de rétablir la position d'une entité que de la réinsérer s'il elle a été supprimée ou de la supprimer si elle a été créée.</p>
<p>Là aussi j'utilise une énumération :</p>
<pre><code class="language-typescript">export enum UndoCUDOpEnum {
    update = 0,
    create,
    delete
}
</code></pre>
<p>Le constructeur de <strong>DrawingAction</strong> initialise l'état courant "<strong>prevState</strong>" avec un clone de l'entité.</p>
<pre><code class="language-typescript">private cloneState(e: any): any {
    return JSON.parse(JSON.stringify(e));
}
</code></pre>
<p>"<strong>prevState</strong>" peut sembler un nom assez inapproprié pour désigner l'état courant mais il faut bien voir que lorsqu'on aura fait une opération undo, les deux états "<strong>prevState</strong>" et "<strong>nextState</strong>" auront été échangés et que "<strong>prevState</strong>" correspondra effectivement à l'état précédant l'opération undo.</p>
<h3>Ending an update</h3>
<p>Lorsqu'une opération de modification est terminée, le [service](#undo service) valorise le nouvel état des entités concernées pour chaque <strong>DrawingAction</strong> :</p>
<pre><code class="language-typescript">push(e: any): boolean {
    this.nextState = this.cloneState(e);
    this.status = UndoStateEnum.restored;
    // return false if the entity has no changes
    return prevState !== this.nextState;
}
</code></pre>
<p>On clone l'état de l'entité modifiée comme on l'avait fait pour <strong>prevState</strong> dans le constructeur. <strong>status</strong> qui était <strong>UndoStateEnum.pending</strong> dans le constructeur devient <strong>UndoStateEnum.restored</strong>. Restored parce qu'il n'y a pas de différence entre un état courant après modification et rétabli après un redo. C'est la même ambiguïté de nom qu'on a vu plus haut avec <strong>prevState</strong>.</p>
<p>Pourquoi est-il nécessaire de passer <code>(e: any)</code> à la fonction push puisqu'on a déjà stocké <strong>entity</strong> à l'initialisation. Il s'agit d'un pointeur donc son état <strong>est</strong> l'état modifié. On pourrait très bien faire <code>this.nextState = this.cloneState(this.entity);</code> non? Et bien non car dans le cas d'une opération d'insertion l'entité n'existe pas encore au moment de l'initialisation de <strong>DrawingAction</strong>. <strong>entity</strong> et <strong>prevState</strong> sont undefined. Et ici à l'inverse c'est lors d'une opération de suppression que <strong>e</strong> et <strong>nextState</strong> sont undefined puisqu'à ce moment l'entité n'existe plus.</p>
<p>Cette fonction retourne false si les deux états sont identiques. Cela indique que l'entité n'a pas été modifiée, ce qui se produit si l'opération de modification a été annulée par l'utilisateur avant d'être terminée. Ce retour permet au [service](undo service) de savoir s'il doit conserver la <strong>DrawingAction</strong> ou non.</p>
<h3>Undoing / redoing</h3>
<p>Enfin il reste à écrire les deux méthodes undo et redo, ce qui est élémentaire puisqu'il s'agit juste d'intervertir les deux états et de changer le statut.</p>
<pre><code>undo(): void {
    this.switchState(UndoStateEnum.undone);
}

redo(): void {
    this.switchState(UndoStateEnum.restored);
}

private switchState(status: UndoStateEnum): void {
    const tmp = this.prevState;
    Object.assign(this.entity, this.prevState);
    this.prevState = this.nextState;
    this.nextState = tmp;
    this.status = status;
}
</code></pre>
<h3>In a nutshell</h3>
<p>Pour résumer ce chapitre, voilà la classe <strong>DrawingAction</strong> en entier. This little piece of code is able to store and manage undo and redo ops.</p>
<pre><code class="language-typescript">export class DrawingAction {
    entity: any;
    prevState: any;
    nextState: any;
    status: UndoStateEnum = UndoStateEnum.pending;
    cudOp: UndoCUDOpEnum;
    
    constructor(e: any, cudOp: UndoCUDOpEnum) { 
        this.entity = e;
        this.cudOp = cudOp;
        this.prevState = this.cloneState(e);
    }

    push(e: any): boolean {
        this.nextState = this.cloneState(e);
        this.status = UndoStateEnum.restored;
        // return false if the entity has no changes
        return JSON.stringify(this.entity) !== this.nextState;
    }

    undo(): void {
        this.switchState(UndoStateEnum.undone);
    }

    redo(): void {
        this.switchState(UndoStateEnum.restored);
    }

    private switchState(status: UndoStateEnum): void {
        const tmp = this.prevState;
        Object.assign(this.entity, this.prevState);
        this.prevState = this.nextState;
        this.nextState = tmp;
        this.status = status;
    }

    private cloneState(e: any): any {
        return JSON.parse(JSON.stringify(e));
    }
}
</code></pre>
<h2>Undo service</h2>
<p>Passons maintenant au service qui reçoit les notifications de changement et stocke les états successifs des entités modifiées.</p>
</article>
        </div>
    
</body>
</html>