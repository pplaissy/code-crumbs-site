<!doctype html>
<html lang="en">
<head>
        <base href="../..">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Some code crumbs dropped along my coding <path/>">
        <meta name="keywords" content="Eleventy, Web Components, JS, HTML, JavaScript, SVG">
        <meta name="generator" content="Eleventy">
        <meta name="author" content="Pierre Plaissy">

        <meta property="og:title" content="Managing model events in MVVM pattern context">
        <meta property="og:type" content="article">
        <meta property="og:URL" content="https://code-crumbs.pplaissy.fr/posts/mvvm-model-events/">
        <meta property="og:image" content="https://code-crumbs.pplaissy.fr/assets/img/mvvm-model-events/thumbnail.png">
        <meta property="og:description" content="In a project where it is not the view that drives but the model how to make the different parts of the model communicate">

        <title>Code crumbs</title>
        <link rel="icon" href="assets/img/favicon.ico">
        <link rel="stylesheet" href="assets/css/main.css">
        <link rel="stylesheet" href="assets/css/posts.css">
    </head>
    <body>
        <nav class="header">
  <div class="avatar">
    <img src="assets/img/me.png" alt="me" class="profile-img mr">
    <!-- <span class="copy" @html="'&copy; ' + currentYear() + ' P. Plaissy'"></span> -->
    <!-- <span>P. Plaissy</span> -->
  </div>
  <div class="title">
    <div class="main">
      <a href="#" class="nav-item mr">code crumbs</a>
      <a href="https://www.linkedin.com/in/pierreplaissy/" aria-label="LinkedIn" target="_blank" rel="noopener noreferrer" class="linkedin">
    <img src="assets/img/linkedin.svg" alt="LinkedIn" width="24" height="24" class="mb-1">
</a>

    </div>
    <!-- <div class="epigraph">
      <span>Some code crumbs dropped along my coding &lt;path&#47;&gt;</span>
    </div> -->
  </div>
</nav>
<link rel="stylesheet" href="assets/css/header.css">

        <div class="main-container">
            <h1>Managing model events in MVVM pattern context</h1>
<article><p>NOTE: The examples used here are coded in Angular and PrimeNG. The syntax might be different with another stack. The file structure is simplified. I've removed everything automatically generated by the framework that was unnecessary for the demonstration, to make it easier to read. The data loading cycle is not implemented, again for the sake of clarity.</p>
<p>In a project where it is not the view that drives but the model how to make the different parts of the model communicate.</p>
<h2>About standard event binding</h2>
<p>State changes and user interactions are events that induce changes in the UI and underlying data. A notification received on a messaging thread listened by the application, a user click on an interface button or a keystroke on the keyboard are events that produce changes, both visible and invisible.</p>
<p>Any DOM lib seamlessly integrates the management of these events by allowing an interface element (a DOM tag) to be linked to an underlying element (a model value or function) using a dedicated syntax. Intercepting the click on a button, for example, means declaring in the view that you wish to link the mouse click <code>(click)</code> to a function you have to write elsewhere, called <code>onSave()</code>. This is achieved by the following declaration: <code>&lt;button (click)="onSave()"&gt;Save&lt;/button&gt;</code>.</p>
<p>In short, all this is well known to any developer, but that's not the point. If, like me, you're looking to decouple the view from the model as much as possible (<a href="https://angular.fr/get_started/mvvm.html">MVVM pattern</a>), you'll need an additional mechanism to link events between the different classes in your view model.</p>
<h2>Simple MVVM event feature</h2>
<p>A simple example to get you started with menu item click management. Each menu item declares a command property <code>command: () =&gt; this.menuItemClick(#menuId)</code> which refers to a method that centralizes clicks and executes the listener method if one has been declared. The menu item id is passed directly as an argument, but to reinforce type control we could use an abstract EventArg class with different variations for different types of events.</p>
<p>This is a kind of dependency injection. The listener injects its listening method into the class that produces the event. In this example, we're talking about <strong>AppVM</strong>, which is the root of the view model, and <strong>ToolbarVM</strong>, which is the model underlying the component.</p>
<p>Here's how it looks in the application:</p>
<p><img src="assets/img/mvvm-model-events/mvvm-events01.gif" alt="simple event binding"></p>
<p>This is a very convenient way of connecting two classes that have a direct relationship, in this case from parent to child. It is, however, limited by the fact that :</p>
<ul>
<li>classes must be aware of each other in the model tree, i.e. if we can declare <code>this.toolbarVM.menuItemClicked = this.menuItemClicked.bind(this);</code> in the <strong>AppVM</strong> ctor it's because, in this context, we have both an instance of <strong>AppVM</strong> and an instance of <strong>ToolbarVM</strong>.</li>
<li>there can only be one listener for an event.</li>
</ul>
<h2>Extended MVVM event feature</h2>
<p>We'll now look at how we can resolve these two limitations, i.e. :</p>
<ul>
<li>allow multiple listeners for the same event</li>
<li>allow a listener to be connected to a remote emitter. Distant both in the view model tree and in the application lifecycle. The listener and sender can be arbitrarily distant in the view model tree and instantiated at different times in the application lifecycle.</li>
</ul>
<p>Although more sophisticated than the above simple version, the complete solution nevertheless boils down to a few classes and little code:</p>
<table>
<thead>
<tr>
<th>Event classes</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>EventCallbackStore</td>
<td>events callbacks store</td>
</tr>
<tr>
<td>EventEmitter</td>
<td>event emitter model must inherit from this abstract base class</td>
</tr>
<tr>
<td>EventListener</td>
<td>event listener model must inherit from this abstract base class</td>
</tr>
<tr>
<td>EventProcess</td>
<td>events callback wrapper as stored in <strong>EventCallbackStore</strong></td>
</tr>
<tr>
<td>IEventListener</td>
<td>contract structure for an event model</td>
</tr>
<tr>
<td>ModelEventLifeCycle</td>
<td>abstract base class for view components whose model is an <strong>IEventListener</strong></td>
</tr>
<tr>
<td>AppEventsEnum</td>
<td>just an enum for events names</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Utilities classes</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>readableUUID</td>
<td>small function to return a human readable unique id for better console log experience</td>
</tr>
<tr>
<td>LoggerService</td>
<td>console log utilities with messages grouping and prod context checking</td>
</tr>
</tbody>
</table>
<p>Note that this solution requires a dependency injection system. I use the Microsoft lib <a href="https://github.com/microsoft/tsyringe">tsyringe</a>.</p>
<h3>A few pointers about MVVM</h3>
<p>You'll note in passing the particular architecture used for MVVM. A view component is linked to its view model via an injected property that I always call 'model'.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">RightPanelComponent</span> <span class="token keyword">extends</span> <span class="token class-name">ModelEventLifeCycle</span> <span class="token punctuation">{</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Input</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> override model<span class="token operator">:</span> RightPanelVM <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>The view is only loaded into the DOM when 'model' is instantiated:</p>
<pre class="language-html"><code class="language-html">@if (model) {
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>flex flex-column gap-5<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">&gt;</span></span>Right panel<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>
        ...
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
}</code></pre>
<p>And of course, with the exception of the root of the view model tree, which is initialized by the root page (<strong>AppComponent</strong> instancie <strong>AppVM</strong>), it's never the view component that instantiates its model, but it's because an instance of the model is created by its parent model that the corresponding view is injected into the DOM.</p>
<p>It's the model tree that drives the view tree.</p>
<p>There is nothing more than the declaration of the view model in the component's ts file. Coupling between view and model is thus reduced to an absolute minimum.</p>
<h3>ModelEventLifeCycle</h3>
<p>Listeners are callback methods that are called when the event is emitted. Since there may be several listeners for the same event, several callbacks will be executed when the event is emitted.</p>
<p>But when a listener is destroyed, for example when a view changed because the view model is no longer in use, we want to ensure that the callbacks associated with this listener are immediately destroyed.</p>
<p>The method consists in using the <code>ngOnDestroy()</code> of the view component life cycle to destroy callbacks. Each view component whose view model is an event listener must extend a <code>ModelEventLifeCycle</code> base component.</p>
<pre class="language-ts"><code class="language-ts"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Component</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> template<span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ModelEventLifeCycle</span> <span class="token keyword">implements</span> <span class="token class-name">OnChanges</span><span class="token punctuation">,</span> OnDestroy <span class="token punctuation">{</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Input</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> model<span class="token operator">:</span> IEventListener <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

    <span class="token function">ngOnChanges</span><span class="token punctuation">(</span>changes<span class="token operator">:</span> SimpleChanges<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> modelChanges <span class="token operator">=</span> changes<span class="token punctuation">[</span><span class="token string">"model"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>modelChanges <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>modelChanges<span class="token punctuation">.</span>firstChange <span class="token operator">&amp;&amp;</span> modelChanges<span class="token punctuation">.</span>previousValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// remove the listeners if a new instance of the model is created</span>
            <span class="token punctuation">(</span>modelChanges<span class="token punctuation">.</span>previousValue <span class="token keyword">as</span> IEventListener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">ngOnDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
        <span class="token comment">// remove the listeners</span>
        <span class="token comment">// in some cases, model and listeners could have been already destroyed par the parent model</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span><span class="token function">removeListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>This component deletes callbacks when the view model is reinstantiated or the component is removed from the DOM.</p>
<p>A view component whose model is an event listener must extend <code>ModelEventLifeCycle</code> and override the base model with its own view model. <code>@Input() override model:...</code>.</p>
<h3>IEventListener</h3>
<p>A view model that needs to listen to events must implement this interface, whose contract includes a unique identifier and two methods for managing listening.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IEventListener</span> <span class="token punctuation">{</span>
    invariantId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    <span class="token function">addEventListener</span><span class="token punctuation">(</span>methodName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> method<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
    <span class="token function">removeListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3>readableUUID</h3>
<p>Just a small tool to return a human readable unique id for better console log better experience.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">readableUUID</span><span class="token punctuation">(</span>prefix<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prefix<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>crypto<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>Which in the console results, for example, in :</p>
<p><img src="assets/img/mvvm-model-events/readable-uuid-in-console.png" alt="readable UUID"></p>
<h3>EventProcess</h3>
<p>When an <strong>IEventListener</strong> view model add a new event listener, an <strong>EventProcess</strong> is registered into the event callback store.</p>
<pre class="language-ts"><code class="language-ts"><span class="token comment">// EventCallbackStore excerpt</span>
<span class="token function">addEventListener</span><span class="token punctuation">(</span>listenerId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> eventName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> method<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> process <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getProcess</span><span class="token punctuation">(</span>listenerId<span class="token punctuation">,</span> eventName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// if the process already exists, replace the callback method</span>
        process<span class="token punctuation">.</span>method <span class="token operator">=</span> method<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// else create a new event process</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>processes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EventProcess</span><span class="token punctuation">(</span>listenerId<span class="token punctuation">,</span> eventName<span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3>EventEmitter</h3>
<p>What does it mean to emit an event ? When a EventEmitter view model call its <code> async emitEventAsync(eventName: string, arg1?: any): Promise&lt;any&gt; {}</code> method, it execute each <strong>EventProcess</strong> stored in the <strong>EventCallbackStore</strong> whose that have the same <strong>eventName</strong> which is equivalent for the event to being received by the listener, because the EventProcess callback method belongs to the listener.</p>
<h3>EventListener</h3>
<p>A view model can be just an <strong>EventEmitter</strong> if it doesn't need to listen to any event. But an <strong>EventListener</strong> is also an <strong>EventEmitter</strong>. this architecture is due to the limitation of type script, which does not allow mutliple inheritance. So <strong>EventListener</strong> extends <strong>EventEmitter</strong>.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">EventListener</span> <span class="token keyword">extends</span> <span class="token class-name">EventEmitter</span> <span class="token keyword">implements</span> <span class="token class-name">IEventListener</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre>
<p>An <strong>EventListener</strong> must be instanciated with a unique identifier that is generated using the <strong>readableUUID</strong> tool.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">RightPanelVM</span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token function">readableUUID</span><span class="token punctuation">(</span>RightPanelVM<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">...</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span></code></pre>
<p>And call its addEventListener base method to register in the EventCallbackStore in the name of the listener unique id.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>#event name#<span class="token punctuation">,</span> <span class="token punctuation">(</span>#event arg#<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    #callback instructions#
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Note that the callback method can be async, very handy to wait for an api call result.</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>#event name#<span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>#event arg#<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2>The sample app</h2>
<p>I've made an sample playground application to demonstrate how it works, which you can find on <a href="https://github.com/pplaissy/MVVM-model-events">github</a>.</p>
<p>A menu bar and a content divided in two panels, left and right. The left panel listens to the right panel and vice versa. The menu bar listens to the two content panels. When a panel send a message event, the over one displays the incoming message and the menu bar counts sent messages.</p>
<p>For each event emitted by a panel, there are two listeners, the other panel and the menu bar. The two panels are two leaves of the model tree. They have no common reference, and therefore no 'knowledge' of each other.</p>
<p>Do you want to play a bit ?</p>
<p><img src="assets/img/mvvm-model-events/mvvm-events02.gif" alt="readable UUID"></p>
<p>Thanks for checking by.</p>
</article>
        </div>
    
</body>
</html>